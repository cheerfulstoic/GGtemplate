= Telco Network Management Using Graph Database

== Introduction

Stuff here

=== The Challenge

Telecommunication companies need a way to predict and warn customers in advance of any service interruptions in order to maintain customer service agreements and avoid financial penalties of unplanned downtime. 

- How can we keep predict potentially catastrophic outages? 
- How can we easily find alternate routes upon network failure?

_question: we can easily model congestion by setting a threshold, but this seems overkill for this very simple example._

== The Network

[ image of telco network from Neo4j presentation/whitepaper ]

//hide
//setup
[source,cypher]
----
//create the resource nodes
CREATE (`1` :subgraph:resource {resource_id:1, name:'Abeer'}), (`2` :subgraph:resource {resource_id:2, name:'An'}), (`3` :subgraph:resource {resource_id:3, name:'Anastasiya'}), (`4` :subgraph:resource {resource_id:4, name:'Anna'}), (`5` :subgraph:resource {resource_id:5, name:'Asley'}), (`6`:resource {resource_id:6, name:'Aziza'}), (`7`:resource {resource_id:7, name:'Bai'}), (`8`:resource {resource_id:8, name:'Barbra'}), (`9`:resource {resource_id:9, name:'Bart'}), (`10`:resource {resource_id:10, name:'Bill'}), (`11`:resource {resource_id:11, name:'Jacob'}), (`12`:resource {resource_id:12, name:'Bobba'}), (`13`:resource {resource_id:13, name:'Cai'}), (`14` :service {service_id:1, name:'STS'}), (`15`:resource {resource_id:15, name:'Cammy'})

//create the channels
CREATE (`1`)<-[:LINKS {status:'open'}]-(`2`), (`1`)-[:LINKS {status:'open'}]->(`4`), (`1`)-[:LINKS {status:'open'}]->(`3`), (`2`)-[:LINKS {status:'open'}]->(`3`), (`2`)-[:LINKS {status:'open'}]->(`4`), (`3`)-[:LINKS {status:'open'}]->(`5`), (`4`)-[:LINKS {status:'open'}]->(`5`),(`14`)-[:LINKS {status:'open'}]->(`13`),(`14`)-[:LINKS {status:'open'}]->(`8`),(`14`)-[:LINKS {status:'open'}]->(`7`),(`7`)-[:LINKS {status:'open'}]->(`6`),(`8`)-[:LINKS {status:'open'}]->(`9`),(`13`)-[:LINKS {status:'open'}]->(`10`),(`10`)-[:LINKS {status:'open'}]->(`11`),(`10`)-[:LINKS {status:'open'}]->(`12`),(`12`)-[:LINKS {status:'open'}]->(`11`),(`13`)-[:LINKS {status:'open'}]->(`8`), (`7`)-[:LINKS {status:'open'}]->(`8`), (`8`)-[:LINKS {status:'open'}]->(`6`),(`6`)-[:LINKS {status:'open'}]->(`1`),(`15`)-[:LINKS {status:'open'}]->(`9`),(`13`)-[:LINKS {status:'open'}]->(`9`)
----
//graph

In this example network, one service (the differently-colored node) provides services to a variety of clients through a network of linked resources. Each link is in one of three states: 'open', 'closed', or 'broken'. If a resource is using a link, it is considered 'closed', and no other resource can use it. If a resrouce is not using a link, it is considered 'open'. If something happens to a link that causes it to become unusable, the link is considered 'broken', and the network is at risk for an outage.  


=== Uncovering the Need for Additional Redundancy

Although most of the resources in our example network above are connected to the main service by multiple links, there are some subsections of the network that are connected by only one link (a bridge). Although this lack of redundancy might be necessary due to lack of funds or other reasons, if this bridge is broken, a large chunk of our network will suffer an outage. Redundancy is necessary both for the avoidance of outages and well-planned redundancy necessary to keep costs under control. 


=== Finding and dealing with bridges

A bridge refers to an edge (or in Neo4j, a relationship), that when deleted, increases the number of connected components. In the example below, both edge a or b could be bridges, as their deletion would result in two connected components, only one of which would include Bob. 

image::http://i.imgur.com/DvwWxMI.png[example]

_replace this image with an image of this network, update names_

Let's find bridges in our network:

[source,cypher]
----
MATCH path = (a:resource)-[r0]->(b:resource)
WHERE NOT (a)-[*3]-(b) AND NOT (a)<--(b)
RETURN DISTINCT a.resource_id AS `Endpoint 1 ID`, a.name AS `Endpoint 1 Name`, b.resource_id AS `Endpoint 2 ID`, b.name AS `Endpoint 2 Name`, r0
----

_insert images of the bridges_

_insert description of what's going on at each bridge_ 

Naturally, if anything happens to any of these channels a chunk of of our network will go down. Ideally, we'd have redundancies and multiple backups to take care of any possible outage. However, resources and the implementation of resources are expensive. 

=== Resilience During Unplanned Network Outages

==== Introduction

Let's take a look at the subgraph connected by the bridge between network resource 1 and 6. 

_insert detailed diagram of this subgraph_

[source,cypher]
----
MATCH path = shortestPath((a:subgraph)-[*..3]-(b))
WHERE NOT (b:subgraph)
RETURN DISTINCT a.resource_id AS `RESOURCE ID`, min(length(relationships(path))) AS `DISTANCE TO NETWORK`
ORDER BY `RESOURCE ID` ASC
----


The need for additional connections evident: if a drunk driver or nest of squirreles were to eliminate this bridge, the entire subgraph will go down. The next question: Assuming the owner of the netowrk has the funds for only one additional link to the subgraph, what is the optimal location to place it? 

For this example, let's make the following assumptions about the network and the network owners' needs:

- While resource A is communicating with resource B through a link or set of channels, no other resource can use the link for the duration of the communication. 
- When it rains it pours: We are trying to determine where to place additional links based on the worst case scenario. 
 * More than one channel will fail at the same time, and we know the channels between resource 3 and 1 and 3 and 2 are in a particularly vulnerable area. 
 * During crisis all resources will be trying to reach the parent network simultaneously, causing network congestion

==== Modeling the Crisis

_insert image of subcomponent with the vertices [3,1] and [3,2] broken, with resource 1 as the obvious connection to the outside world_

*_A catastrophe has befallen the links between resource 3 and resources 2 and 1._*

[source,cypher]
----
MATCH p =(a:subgraph)-[r]-(b:subgraph)
WHERE a.resource_id = 3 AND b.resource_id < 3
SET r.status = 'broken'
RETURN a.resource_id, r.status, b.resource_id
----
//table


In the worst case scenario, all resources are trying to contact resource 1 in an effort to reach the service node. Although in the real world this would happen near simultaneously, let's look at the paths one by one. 

First, resource 2 attempts to reach resource 1 through the open links. If it succeeds, it sets all links on the path to 1 as 'closed': 

[source,cypher]
----
MATCH p = shortestPath((a:subgraph)-[r*..3]-(b:subgraph))
WHERE a.resource_id = 1 AND b.resource_id = 2 AND ALL (r1 IN relationships(p) WHERE r1.status='open')
FOREACH (x IN relationships(p) | SET x.status = 'closed')
RETURN relationships(p)
----
//table

Resource 3 tries to reach resource 1 through the open links. If it succeeds, it too sets all links on the path to 1 as 'closed':

[source,cypher]
----
MATCH p = shortestPath((a:subgraph)-[r*..3]-(b:subgraph))
WHERE a.resource_id = 1 AND b.resource_id = 3 AND ALL (r1 IN relationships(p) WHERE r1.status='open')
FOREACH (x IN relationships(p) | SET x.status = 'closed')
RETURN DISTINCT relationships(p)
----
//table


Now resource 4 attempts to reach resource 1:

[source,cypher]
----
MATCH p = shortestPath((a:subgraph)-[r*..3]-(b:subgraph))
WHERE a.resource_id = 1 AND b.resource_id = 4 AND ALL (r1 IN relationships(p) WHERE r1.status='open')
FOREACH (x IN relationships(p) | SET x.status = 'closed')
RETURN relationships(p)
----
//table

All possible paths to resource 1 are closed to resource 4.

Resource 5 attempts to reach resource 1: 

[source,cypher]
----
MATCH p = shortestPath((a:subgraph)-[r*..3]-(b:subgraph))
WHERE a.resource_id = 1 AND b.resource_id = 4 AND ALL (r1 IN relationships(p) WHERE r1.status='open')
FOREACH (x IN relationships(p) | SET x.status = 'closed')
RETURN relationships(p)
----
//table

All possible paths to resource 1 are closed to resource 5. 

In the case of network congestion and the failure of two links, two resources are unable to reach the service. As we have only enough resources for one additional link from the network, we now have to determine an appropriate location for the new link. 

*_Planning the new link_*

Assuming resources 3, 4, and 5 are of equal priority, and that the links between 1 and 3 and 2 and 3 will continue to have problems with connectivity, we still have a few options in which to place our new link. Recall that in the intact network resource 5 has the longest path to the network. 

A link at 5:

- Gives resource 5 a shorter path to the network when there are no outages (path of length 3 to path of length 1)
- Allows resource 3 to contact the network without blocking resource 4s' access to the network
- In the scenario described above (congested network with weak links down), one resource (either 3 or 5) will still be unable to access the network 

A link at 4:

- Gives resource 5 a shorter path to the network when there are no outages (path of length 3 to path of length 2)
- Does not allows resource 3 to contact the network without blocking resource 4s' access to the network
- In the scenario described above (congested network with weak links down), one resource (3) will still be unable to access the network 

A link at 3:

- Gives resource 5 a shorter path to the network when there are no outages (path of length 3 to path of length 2)
- Allows resource 3 to contact the network without blocking resource 4s' access to the network
- In the scenario described above (congested network with weak links down), one resource (either 4 or 5) will still be unable to access the network 

Since all options result in one resource being blocked and placing a link at resource 5 results in the shortest path for resource 5 in both the damaged and intact network, let's place the new link at resource 5. 

[source,cypher]
----
MATCH (a {resource_id: 5}), (b:service)
MERGE (a)<-[:LINK {status:`open`}]-(b)
----
//table


[source,cypher]
----
MATCH path = shortestPath((a:subgraph)-[*..3]-(b))
WHERE NOT (b:subgraph)
RETURN DISTINCT a.resource_id AS `RESOURCE ID`, min(length(relationships(path))) AS `DISTANCE TO NETWORK`
ORDER BY `RESOURCE ID` ASC
----

== Conclusion/Discussion

=== more conclusion copy

conclusion stuff

=== Sub-graph Fault Tolerant Routing

_Subgraph Fault-Tolerant Routing (SFTR)_ is a strategy for planning for the inevitable - resource or connection outage. Sometimes a squirrel builds a nest in part of your network. Although we have to accept that parts of our networks will break, we can also determine which components will be able to reroute and which will have the potential to be catastrophic failures.

L+1 sub-graph routing is a strategy for routing dependable connections in optical networks. In this approach each network is mapped into L distinct sub-graphs resulting from the removal of links (in this example, only one link) from the original network.

A connection from node A to B in this scheme becomes “accepted”–in other words, identified as not potentially catastrophic–only if it is there is a path from A to B in all sub-graphs. Ideally, we would design a network in which there is always a path from A to B given any network failure.

=== Why Neo4j?

The problem of modeling a live Telco network was a good fit for Neo4j’s solution, which uses nodes and relationships to describe assets on the network (switches, routers, cell towers), and the links between them (trunks, fiber optic cables, VPNs). Neo4j places no restrictions on the way the data is structured, or the data that is captured: it can model and represent the new network in a natural way. This extreme flexibility saves a great deal of time, and makes it possible to represent complex data and abstract concepts at the same time, within the same database. This is extremely powerful.

=== Additional things telcos need to worry about that neo4j could help solve

== Actual Use Case: Vivendi SFR

- Second largest communications company in France
- Part of Vivendi Group, partnering with Vodafone

SFR tasked a 10-person project team to find a network management solution, and brought in software consultants from London-based OpenCredo to provide best practice expertise. The team selected the Neo4j graph database to build a proof of concept app that could pinpoint any “single point of failure” across the components of the SFR multi-system network.

== Cypher Appendix

Briefly go over the queries in more detail

=== Setting up the Graph

=== Uncovering the Need for Additional Redundancy

==== Finding Bridges

==== Adding Bridges

=== Resilience During Unplanned Network Outages

==== Removing Links

==== Finding (the best) secondary routes for emergencies

== References

- those two Frederick et al papers
- Neo4j ‘intro slides’ and graph connect presentations
- Neo4j telco white paper
- 'http://en.wikipedia.org/wiki/Samuel_Johnson[Networks, Crowds, and Markets]'
- 'http://jexp.de/blog/2014/03/sampling-a-neo4j-database/[Sampling a Neo4j Database]'


== reasons for broken links (source: STS Telecom):
- squirrels
- drunk people
- drunk people shooting at squirrels
- homeless people lighting a fire that melts housing
- car accidents
- backhoes
- people stealing fiber thinking it's copper
- train derailments
- car accidents
- pole coming down